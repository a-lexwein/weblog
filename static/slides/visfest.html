<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Thinking Abstractly</title>
    <meta charset="utf-8" />
    <meta name="author" content="Alex Wein" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Thinking Abstractly
## with charts, sets, and functions
### Alex Wein
### 2019-08-29 (updated: 2019-08-26)

---


# Links

## These slides ðŸ‘‰ [alex-we.in/slides/visfest](https://alex-we.in/slides/visfest)
### Textbook: [Formal Foundations of Linguistic Theory](http://coffeeblack.org/publications/Pollard-Martin-FFLT.pdf) by Pollard and Martin
## More notes maybe here

---

# Thanks!

* Stephanie Tuerk, Tony Chu, and Jason Forrest
* The visfest organizers
* Ohio State Linguistics and Haverford College Math departments
* Data Visualization Society, [vis.social](https://vis.social), and generally everyone in the data viz building the type of community I want to be a part of.


---
background-image: url(images/alexwein-dataperson.png)
background-size: contain


---

# Math

1. ### Assumptions
1. ### Definitions
1. ### Inferences

## `\(=\)` &amp;nbsp;&amp;nbsp; vs.&amp;nbsp;&amp;nbsp; `\(=_{def}\)`

---

# Set theory is a foundation for the rest of math

1. Define natural numbers in terms of sets
1. Define integers in terms of natural numbers
1. Rational numbers are based on integers
1. Real numbers are constructed from rational numbers.

---
background-image: url(https://uploads-ssl.webflow.com/5b1d427ae0c922e912eda447/5b5679eed1ecea66513ef29d_examples.jpg)
background-size: contain

Credit [Tai-Denai Bradley's What is Category Theory](https://www.math3ma.com/blog/what-is-category-theory-anyway)


---
background-image: url(images/dvs-survey-1.png)
background-size: contain
class: center, middle

---

# This is a Data Viz workshop, right?

1. We'll leverage intuitions about viz to understand set theory.
1. Viz isn't just about the visuals, it's about the mapping from data to visuals.
1. Data and visualization are not programming concepts.
1. Gives us a little bit of machinery to compare different types of data viz.
1. Datasets are sets*.

---

# Data sets are sets*

1. A data table is a set of rows?
1. Or is it a set of columns?


--

1. Both



---

# Where we're going: **functions**

1. A function is a special kind of relation
1. A relation is a subset of a cartesian product
1. A cartesian product is a special set of ordered pairs
1. An ordered pair is a special kind of set

#### A function is a special kind of set which is a special kind of set built from a special kind of set of special kinds of sets.

---

# Sets

It's a collection of things.  That's it.

Sets are defined solely in terms of membership. Given any two sets `\(A\)` and `\(B\)`, either:

`\(A \in B\)` or `\(A \notin B\)`.

`\(\in\)` means "is in" or "is a member of"
`\(\notin\)` means "is not in"

---

# Assumptions for Set Theory

1. Extensionality
1. Empty Set
1. Pairing
1. Union
1. Powerset
1. Separation

* We'll cover the above, but there are a few more to get to the fully standard set theory Zermelo-Frankel Choice (**ZFC**):

1. Natural Numbers
1. Replacement
1. Foundation
1. Choice

--

# Also, we're skipping over a lot of formalism.

---

# Assumption 1 - Extensionality

## We need to define equality.

## Two sets are "the Same" if they have the same members ( `\(A = B\)` )

`\(\{a, b, c\}  = \{b, a, c\}  = \{a,a,a, b , c\}\)`

Order doesn't matter, uniqueness is baked into the definition.

---

# Subset: `\(A \subseteq B\)`

We say "A is a subset of B" if every element of A is an element of B.

Every set is a subset of itself.

If `\(A \subseteq B\)` and `\(B \subseteq C\)`, then `\(A \subseteq C\)`

1. dogs are a subset of animals
1. dogs named Sparky are a subset of dogs.
1. dogs named Sparky are a subset of animals.
1. natural numbers are a subset of integers.
1. Youtube Employees are a subset of Google Employees.
1. Every scatterplot ever made is a subset of every data visualization ever made.

Given two sets, either the first is a subset of the second or its not!

If "A is not a subset of B" ( `\(A	\nsubseteq B\)` ), that means there's some element `\(b \in B\)` where `\(b \notin A\)`.

---
![](images/subset-sandwich.png)

---

# Assumption 2 -  Empty Set `\(\varnothing\)`

Set membership and equality don't actually give us any sets.  We need to give ourselves a starting point.

Let's assume there exists a set containing no elements.  We can denote it as `\(\{\}\)`, but it's helpful to give the empty set its own symbol `\(\varnothing\)`.

**Vacuous Quantification** - when you have a definition based on "every member of a set", it's going to be true for the empty set. For instance, `\(\varnothing\)` is a subset of every other set.

---

# Assumption 3 - Pairing `\(\{ A, B \}\)`

Given two sets A and B, we can construct a set with just those two elements.


**Singleton**: special case when `\(A = B\)`...pairing gives us  `\(\{A, A\} = \{A\}\)`

---

# Infinite Sets from Nothing

1. Assumption 2 gave us exactly one set to build with: `\(\varnothing\)`.
1. Let's apply pairing to construct a new (different) set `\(\{\varnothing\}\)`. These are not the same set!
1. Now we have two sets.
  1. We can now pair `\(\{\varnothing\}\)` with itself to get `\(\{\{\varnothing\}\}\)`
  1. Or we can pair `\(\{\varnothing\}\)` with `\(\varnothing\)` to get `\(\{\varnothing,\{\varnothing\}\}\)`.
1. We can go on and on like that forever, it's a good way to define the natural numbers `\(\{0, 1, 2, ...\}\)`.

---

# Assumption 4 - Union: `\(\bigcup A\)`

Given a set `\(A\)`, there's a set containing every element of every element of `\(A\)`.

So supposed we have three sets

$$ X = \\{a,b,c\\} $$
$$ Y = \\{c,d,e\\}$$
$$ Z = \\{f\\}$$

Then `\(\bigcup \{X,Y,Z\}\)` is equal to

$$ \\{ a,b,c,d,e,f \\} $$
--

## The binary form is helpful syntax:

# `\(A \cup B =_{def} \bigcup \{A,B\}\)` 

---

# Assumption 5 -  Powerset: `\(P(A)\)`

For any set A, there's a sets whose members are the subsets of A.

So, no matter what A is, we know `\(\varnothing \in P(A)\)` and `\(A \in P(A)\)`

---
class: center, middle

![](images/powerset-no-lines.png)
---
class: center, middle

![](images/powerset-w-lines.png)

---

# Bertrand Russell's Paradox

--

## Everyone in town shaves. 

--

##The barber shaves everyone who doesn't shave themself, and nobody else.

--

## Does the barber shave himself?  
--
ðŸ¤”


---
# Assumption 6 - Separation

If `\(A\)` is a set and `\(P[x]\)` is a condition on `\(x\)` (where `\(x\)` is a variable that ranges over sets), then there is a set, written

# `\(\{ x \in A \,|\, P[x]\}\)`

whose members are all the x in A that satisfy P[x].

The `\(|\)` symbol can be read as "such that".


---

# Intersection `\(A \cap B\)`

Let's define the intersection of two sets A and B,

# `\(A \cap B =_{def} \{a \in A |\, a \in B\}\)`.

We don't need to assume intersection, because it is a special case of separation.

People who use R and Python.

1. `\(A \cap B = B \cap A\)`
1. If `\(A \subseteq B\)`, then `\(A \cap B = A\)`
1. `\(A \cap \varnothing = \varnothing\)`
1. we say that A and B are **disjoint** if `\(A \cap B = \varnothing\)`


---

## Ordered Pairs `\(\langle A, B \rangle\)`

1. Sets don't have order to them `\(\{ A, B \} = \{ B, A \}\)`.
1. But we want ourselves a way to talk about order.
1. If `\(A \neq B\)`, then we want `\(\langle A, B \rangle \neq \langle B, A \rangle\)`

---

## Definition of an ordered pair

# `\(\langle A, B \rangle = \{\{A\}, \{A,B\}\}\)`


This is built out 3 applications of the pairing assumption.

---

# Cartesian Product, `\(A \times B\)`

The set of all ordered pairs `\(\langle a, b\rangle\)` such that `\(a \in A\)` and `\(b \in B\)`.

---
![](visfest_files/figure-html/unnamed-chunk-1-1.png)&lt;!-- --&gt;

---

# More dimensions.

1. We have ordered pairs. How about triplets.
1. # `\(\langle a,b,c \rangle =_{def} \langle \langle a, b \rangle, b \rangle\)`
1. ##  `\(A \times B \times C =_{def} (A \times B) \times C\)`
1. bigger ordered tuples, and cartesian products are also constructed recursively.

---

# Relations!

## Simple definition; really powerful concept

--

## A Relation `\(R\)` between `\(A\)` and `\(B\)` is a subset of `\(A \times B\)`.

### We can use the notation `\(a\,R\,b\)` to mean `\(\langle a,b \rangle \in R\)`




Important special case `\(B = A\)`, then we have a relation **on** A.

---

## Relations in the real world

1. loves
1. is taller than
1. is at least as tall as
1. is the parent child
1. is the ancestor of
1. is the brother-in-law of
1. Has more privilege than (Eugenia Cheng, Category Theory in Life, https://www.youtube.com/watch?v=ho7oagHeqNc)
1. is friends with
1, is facebook friends with
1. Verbs that relate people to propositions
  * believes, knows, doubts

---

## Representing Relations: Using set notation

# HadForDinner =

$$
\\{
\langle Amir, Pasta \rangle,
\langle Beatrice, PorkChop \rangle,
\langle Carlos, PorkChop \rangle,
\langle\ Carlos, Salad \rangle
\\}
$$

---

## Representing Relations: As a table.

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; person &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; food &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Amir &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Pasta &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Beatrice &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; PorkChop &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Carlos &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; PorkChop &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Carlos &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Salad &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

---

## Representing Relations: As a grid

![](visfest_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---
## Order doesn't matter for sets.

### These are equivalent:

.pull-left[
![](visfest_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;
]

.pull-right[
![](visfest_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;
]



---
## Representing Relations: using nodes and edges

![](images/hadfordinner.png)



---
# Identity Relation on a set `\(A\)`

# `\(id_A = \{\langle x,y \rangle \in A \times A | \, x = y \}\)`

--
&lt;hr&gt;

.pull-left[
![](images/5-el-id-no-label.png)

]

.pull-right[

![](visfest_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;

`\(\{\langle a,a \rangle, \langle b,b \rangle, \langle c,c \rangle, \langle d,d \rangle, \langle e,e \rangle\}\)`

]
---


## Domain and Range

## Given a relation `\(R\)` from `\(A\)` to `\(B\)`

1. # `\(dom(R) = \{ x \in A \,|\, \exists y \in B (x \,R\, y)\}\)`
1. # `\(ran(R) = \{ y \in B \,|\, \exists x \in B (x \,R\, y)\}\)`

`\(\exists\)` reads as "there exists".

---

# Inverse Relation: `\(R^{-1}\)`

 `\(R^{-1} =_{def} \{ \langle x,y \rangle \,|\, y \,R\, x\}\)`

A relation `\(R\)` is a subet of `\(A \times B\)`, its inverse `\(R^{-1}\)` is the subset of `\(B \times A\)` obtained by swapping the order of the pairs (reversing the arrows).

---

# `\(HadForDinner^{-1}\)`

![](images/hadfordinner-inverse.png)

---

# Examples of inverse relations:

1. is greater than; is less than
1. loves; is loved by
1. is the parent of; is the child of
1. is the sibling of; is the sibling of

---
# Composition

Given two relations, we can combine them: Since they're just sets, we can union them together or take their intersection, but we can also compose them:

1. Given R is a relation from A to B
1. Given S is a relation from B to C
1. ### `\(S \circ R =_{def} \{ \langle x,z \rangle \in A \times C \,|\, \exists y \in B (x\,R\,y \wedge y\,S\,z)\}\)`
1. A few new symbols: The subset of pairs `\(\langle x,z \rangle\)` in `\(A \times C\)` where "there exists a `\(y\)`" ($\exists y$) such that "x is related to Y through R, *and* ($\wedge$) y is related to z through S.
1. Note the order `\(S \circ R\)`: `\(S\)` happens "after" `\(R\)`.

---
background-image: url(images/relation-composition.png)
background_size: contain

---

Examples of relation compostion:

1. is the grandfather of = is the father of the father of.
1. is the brother-in-law of
1. function composition:
  1. If we have `\(f(x) = x^2\)` and `\(g(x) = x + 2\)`
  1. `\(g(f(x)) = x^2 + 2\)`
  1. `\(f(g(x)) = (x+2)^2\)` 

---

# Given a relation R from A to B:

## `\((R^{-1})^{-1}  = R\)`
 
## `\(id_b \circ R = R\)`
 
## `\(R \circ id_a = R\)`

---

# Special Properties of Relations on A

1. Reflexive
1. Symmetric
1. Transitive

---

A relation `\(R\)` on `\(A\)` is **reflexive** if `\(x\,R\,x\)` for all `\(x \in A\)`.

* Equivalent definition: `\(id_A \subseteq R\)`

A relation is **irreflexive** if `\(\langle x , x \rangle \notin R\)` for all `\(x \in A\)`.

* Equivalent defintion: `\(id_A \cap R = \varnothing\)`

&lt;br /&gt;
&lt;br /&gt;


![](images/5-elements-reflexive.png)

--

What's do reflexive relations look like as grids?

---

A relation `\(R\)` on `\(A\)` is **symmetric** if `\(a\,R\,b\)` implies `\(a \,R\, b\)` for all `\(a,b \in A\)`.

* Equivalently, `\(R = R^{-1}\)`

A relation is **asymmetric** if `\(a\,R\,b\)` implies `\(\langle a, b \rangle \notin R\)` for all `\(a,b \in A\)`.

* Equivalently, `\(R \cap R^{-1} = \varnothing\)`

A relation is **antisymmetric** if `\(a\,R\,b\)` and `\(a\,R\,b\)` imply `\(a = b\)` for all `\(a,b \in A\)`

* A relation is asymmetric if it is antisymmetric and irreflexive.

&lt;br /&gt;&lt;br /&gt;
![](images/5-elements-symmetric.png)
--

What does a symmetric relation look like as a grid?

---

A relation is **transitive** if `\(a\,R\,b\)` and `\(b\,R\,c\)` implies `\(a\,R\,c\)` for all `\(a,b,c \in A\)`.

* Equivalently: `\(R \circ R \subseteq R\)`

A relation is **intransitive** if `\(a\,R\,b\)` and `\(b\,R\,c\)` implies `\(\langle a,c \rangle \notin R\)` for all `\(a,b,c \in A\)`.

&lt;br /&gt;&lt;br /&gt;
![](images/5-elements-transitive.png)
---
# A few more special relations

&lt;br /&gt;&lt;br /&gt;
![](images/5-elements-prod-id-empty.png)
---
# **Equivalence Relation**

A relation is an equivalence relation if it is reflexive, symmetric, and transitive.

We can use a hamburger: `\(a \equiv b\)` reads as "a is equivalent to b"

![](images/equivalence-relation.png)

An equivlance relation on A partitions A into disjoint subsets.

We'll return to equivalence relations soon.

---

# Functions (we made it!)

A relation `\(F\)` is called a function from A to B, provided for every `\(a\in A\)` there exists a unique `\(b \in B\)` such that `\(a\,F\,b\)`.

1. Notation: `\(F(a) = b\)` "b is the value of F at a"
1. or: `\(F: a \rightarrow b\)` "F maps a to b"

1. `\(A\)` is the **domain** of `\(F\)`.
1. `\(B\)` is the **codomain** of `\(F\)`.
1. The **range** of `\(F\)` is `\(\{b \in B \,|\, \exists a(F(a) = b)\}\)`

---
class: center, middle

![](images/isfun_1to1.png)

---
class: center, middle

![](images/isfun_empty_2to1.png)

---
class: center, middle

![](images/isfun_empty.png)

---
class: center, middle

![](images/isfun_cartesian.png)

---
class: center, middle

![](images/isfun_doesntcover.png)


---
class: center, middle

![](images/isfun_notonto.png)

---

## Do you remember the vertical line test?

![](visfest_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;

---
# Is it a function?

--
1. ## is friends with 
--

1. ## is the boss of
--

1. ## is the mother of
--

1. ## is married to
--

1. ## A = passengers on a airline flight, B = seats on the airplane

---
# Is it a function?

--

1. ## `\(y = 4x^2 - 3x + 4\)`
--

1. ## `\(x^2 + y^2 = 1\)`
--

1. ## `\(y = log(x)\)`
--

1. ### `message =&gt; console.log(message)`
--

1. ### `x =&gt; x + Math.rand()`


---
class: center

### For any function `\(f: A \rightarrow B\)`, there exists an equivalence relation `\(\equiv_f\)` where `\(a \equiv b\)` if `\(f(a) = f(b)\)`

![](images/mod-equivalence.png)
---

# One to One: injective



# Onto: Surjective


# Bijective: one-to-one and onto

if `\(F: A \rightarrow B\)` is a bijective function, then f^{-1} is also a bijective function.

If f isn't bijective, it's inverse is not a function.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
