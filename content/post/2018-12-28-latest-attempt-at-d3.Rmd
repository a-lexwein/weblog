---
title: Latest attempt at D3
author: Akex
date: '2018-12-28'
slug: latest-attempt-at-d3
categories: []
tags:
  - javascript
---

```{r setup}
library(r2d3)
```

"Learn D3" has been on my todo list for years now. Maybe 3 years ago, Me and some teammates (know also didn't no Javascript) tried to play with a simple example. Two summers ago, I worked through Scott Murray's tutorials during a family vacation, after finally learning the ABCs of HTML, CSS, and JS through an online learning platform. I used a tiny bit of D3 in a little word game I made that fall, before I did an 3-month intensive software engineering bootcamp in full-stack javascript, where I didn't 

Learning D3 has been harder for me than learning other things

1. So the hardest part of learning D3 is learning Javascript, HTML, CSS, and SVG.  Once you learn all those things, learning D3 is...still kind of hard.
1. I am not as good at self-motivation as I hope to one day become, but 

1. As someone who has been making charts for a long time (and a R/Tidyverse kool-aid drinker)

I still have never made a chart with data in D3.

# Google for the right bl.ock

One of my issues with D3 is that I only want it when ggplot fails me. So anything I decide, now is the time for D3.


I ended up on Nate Vack's block ["Beeswarm plot with gravity and collisions"](http://bl.ocks.org/njvack/1316832). It was the collision detection. Getting that into RStudio's way of working with D3 took me a while to figure out.  The trick was to replace the section of the block where `svg` was defined, because the RStudio package `rd2d3` handles that by exposing a predefined `svg` variable for you to reference in your javascript code.

Nate's code defines `nodes` which is a randomly assigns a `y`-value based on the `norm()` function defined at the top. Then the nodes are passed into `D3.layout.force`

Here is the Nate's block:

```{d3 echo=FALSE, data=c(1,2,3), d3_version=3}
function norm() {
  var res, i;
  res = 0;
  for (i = 0; i < 10; i += 1) {
    res += Math.random()*2-1
  }
  return res;
}

var w = 500,
    h = 500;

var nodes = d3.range(400).map(function() { 
  var true_y = (norm()*50)+250;
  return {
    radius: 4, 
    y: true_y,
    true_x: 250,
    true_y: true_y }
  });

var force = d3.layout.force()
    .gravity(0)
    .charge(0)
    .friction(0.9)
    .nodes(nodes)
    .size([w, h]);

var root = nodes[0];
root.radius = 0;
root.fixed = true;

force.start();

svg.selectAll("circle")
    .data(nodes)
  .enter().append("svg:circle")
    .attr("r", function(d) { return d.radius; })
    .style("fill", 'steelblue')
    .style("stroke", "black");

force.on("tick", function(e) {
  var q,
    node,
    i = 0,
    n = nodes.length;
    
  var q = d3.geom.quadtree(nodes);

  while (++i < n) {
    node = nodes[i];
    q.visit(collide(node));
    xerr = node.x - node.true_x;
    yerr = node.y - node.true_y;
    node.x -= xerr*0.005;
    node.y -= yerr*0.8;
  }
  


  svg.selectAll("circle")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
});

function collide(node) {
  var r = node.radius,
    nx1,
    nx2,
    ny1,
    ny2,
    xerr,
    yerr;
    
  nx1 = node.x - r;
  nx2 = node.x + r;
  ny1 = node.y - r;
  ny2 = node.y + r;
      
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node.radius + quad.point.radius;
      if (l < r) {
        // we're colliding.
        var xnudge, ynudge, nudge_factor;
        nudge_factor = (l - r) / l * .4;
        xnudge = x*nudge_factor;
        ynudge = y*nudge_factor;
        node.x -= xnudge;
        node.y -= ynudge;
        quad.point.x += xnudge;
        quad.point.y += ynudge;
      }
    }
    return x1 > nx2
        || x2 < nx1
        || y1 > ny2
        || y2 < ny1;
  };
}
```

It seemed like the right place to start, but the chart I have in my head is different from that in a few ways:

1. I want the main axis to be horizontal.
1. Circle color should encode a categorical variable.
1. The circle size should encode a continuous variable.

The variable radius piece was the easiest.  The original block had a line that said `var radius = 4,` in the loop that randomly created the circles.  I replaced it with to assign each circle a radius randomly based on a uniform distribution between zero and seven `var radius = 7 * Math.random(),`

```{d3 echo=FALSE, data=c(1,2,3), d3_version=3}
function norm() {
  var res, i;
  res = 0;
  for (i = 0; i < 10; i += 1) {
    res += Math.random()*2-1
  }
  return res;
}

var w = 500,
    h = 500;

var nodes = d3.range(400).map(function() { 
  var true_y = (norm()*50)+250;
  return {
    radius: 7 * Math.random(), 
    y: true_y,
    true_x: 250,
    true_y: true_y }
  });

var force = d3.layout.force()
    .gravity(0)
    .charge(0)
    .friction(0.9)
    .nodes(nodes)
    .size([w, h]);

var root = nodes[0];
root.radius = 0;
root.fixed = true;

force.start();

svg.selectAll("circle")
    .data(nodes)
  .enter().append("svg:circle")
    .attr("r", function(d) { return d.radius; })
    .style("fill", 'steelblue')
    .style("stroke", "black");

force.on("tick", function(e) {
  var q,
    node,
    i = 0,
    n = nodes.length;
    
  var q = d3.geom.quadtree(nodes);

  while (++i < n) {
    node = nodes[i];
    q.visit(collide(node));
    xerr = node.x - node.true_x;
    yerr = node.y - node.true_y;
    node.x -= xerr*0.005;
    node.y -= yerr*0.8;
  }
  


  svg.selectAll("circle")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
});

function collide(node) {
  var r = node.radius,
    nx1,
    nx2,
    ny1,
    ny2,
    xerr,
    yerr;
    
  nx1 = node.x - r;
  nx2 = node.x + r;
  ny1 = node.y - r;
  ny2 = node.y + r;
      
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node.radius + quad.point.radius;
      if (l < r) {
        // we're colliding.
        var xnudge, ynudge, nudge_factor;
        nudge_factor = (l - r) / l * .4;
        xnudge = x*nudge_factor;
        ynudge = y*nudge_factor;
        node.x -= xnudge;
        node.y -= ynudge;
        quad.point.x += xnudge;
        quad.point.y += ynudge;
      }
    }
    return x1 > nx2
        || x2 < nx1
        || y1 > ny2
        || y2 < ny1;
  };
}
```

To encode color, I first added `color` as a property of each node, randomly assigning it one of two hex codes. To pick colors, I literally just typed letters in having no idea what colors would come out, and kind of liked it.  Then in the section that starts with `svg.selectAll`

```{d3 echo=FALSE, data=c(1,2,3), d3_version=3}
function norm() {
  var res, i;
  res = 0;
  for (i = 0; i < 10; i += 1) {
    res += Math.random()*2-1
  }
  return res;
}

var w = 500,
    h = 500;

var nodes = d3.range(400).map(function() { 
  var true_y = (norm()*50)+250;
  return {
    radius: 7 * Math.random(), 
    y: true_y,
    true_x: 250,
    true_y: true_y,
    color: ['#123456', '#4bab56'][Math.floor(Math.random() + .5)] }
  });

var force = d3.layout.force()
    .gravity(0)
    .charge(0)
    .friction(0.9)
    .nodes(nodes)
    .size([w, h]);

var root = nodes[0];
root.radius = 0;
root.fixed = true;

force.start();

svg.selectAll("circle")
    .data(nodes)
  .enter().append("svg:circle")
    .attr("r", function(d) { return d.radius; })
    .style("fill", d => d.color)
    .style("stroke", "black")

force.on("tick", function(e) {
  var q,
    node,
    i = 0,
    n = nodes.length;
    
  var q = d3.geom.quadtree(nodes);

  while (++i < n) {
    node = nodes[i];
    q.visit(collide(node));
    xerr = node.x - node.true_x;
    yerr = node.y - node.true_y;
    node.x -= xerr*0.005;
    node.y -= yerr*0.8;
  }
  


  svg.selectAll("circle")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
});

function collide(node) {
  var r = node.radius,
    nx1,
    nx2,
    ny1,
    ny2,
    xerr,
    yerr;
    
  nx1 = node.x - r;
  nx2 = node.x + r;
  ny1 = node.y - r;
  ny2 = node.y + r;
      
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node.radius + quad.point.radius;
      if (l < r) {
        // we're colliding.
        var xnudge, ynudge, nudge_factor;
        nudge_factor = (l - r) / l * .4;
        xnudge = x*nudge_factor;
        ynudge = y*nudge_factor;
        node.x -= xnudge;
        node.y -= ynudge;
        quad.point.x += xnudge;
        quad.point.y += ynudge;
      }
    }
    return x1 > nx2
        || x2 < nx1
        || y1 > ny2
        || y2 < ny1;
  };
}
```

Then to swap the axis, I needed to switch `x` and `y`. I was only sort of guessing at what the code did, I figured I needed to change `true_x` and `true_y`.  After some poking, I got it.  In addition to swapping coordinates in the nodes, I also needed to swap the coefficients on `xerr` and `yerr` in the while loop. the Here's the full code with all the changes (I also added an axis):

```{d3, data=c(1,2,3), d3_version=3}
function norm() {
  var res, i;
  res = 0;
  for (i = 0; i < 10; i += 1) {
    res += Math.random()*2-1
  }
  return res;
}

var w = 500,
    h = 500;

var nodes = d3.range(400).map(function() { 
  var true_y = (norm()*50)+250;
  return {
    radius: 7 * Math.random(), 
    x: true_y,
    true_x: true_y,
    true_y: 200,
    color: ['#123456', '#4bab56'][Math.floor(Math.random() + .5)] }
  });


var force = d3.layout.force()
    .gravity(0)
    .charge(0)
    .friction(0.9)
    .nodes(nodes)
    .size([w, h]);

var root = nodes[0];
root.radius = 0;
root.fixed = true;

force.start();

svg.selectAll("circle")
    .data(nodes)
  .enter().append("svg:circle")
    .attr("r", function(d) { return d.radius; })
    .style("fill", d => d.color)
    .style("stroke", "black")

force.on("tick", function(e) {
  var q,
    node,
    i = 0,
    n = nodes.length;
    
  var q = d3.geom.quadtree(nodes);

  while (++i < n) {
    node = nodes[i];
    q.visit(collide(node));
    xerr = node.x - node.true_x;
    yerr = node.y - node.true_y;
    node.x -= xerr*0.5;
    node.y -= yerr*0.008;
  }
  



  svg.selectAll("circle")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
});

function collide(node) {
  var r = node.radius,
    nx1,
    nx2,
    ny1,
    ny2,
    xerr,
    yerr;
    
  nx1 = node.x - r;
  nx2 = node.x + r;
  ny1 = node.y - r;
  ny2 = node.y + r;
      
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node.radius + quad.point.radius;
      if (l < r) {
        // we're colliding.
        var xnudge, ynudge, nudge_factor;
        nudge_factor = (l - r) / l * .4;
        xnudge = x*nudge_factor;
        ynudge = y*nudge_factor;
        node.x -= xnudge;
        node.y -= ynudge;
        quad.point.x += xnudge;
        quad.point.y += ynudge;
      }
    }
    return x1 > nx2
        || x2 < nx1
        || y1 > ny2
        || y2 < ny1;
  };
}
```