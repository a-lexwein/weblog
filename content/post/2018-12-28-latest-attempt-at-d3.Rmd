---
title: Latest attempt at D3
author: Alex
date: '2018-12-28'
slug: latest-attempt-at-d3
categories: []
tags:
  - javascript
---

```{r setup, echo=FALSE}
library(r2d3)
```

Lately, there's been a particular kind of chart I want to make. I guess it's beeswarm plot with variable radius, or maybe a packed circle timeline. Whatever you call it, Keith Collins and Kevin Roose published a story with a [spectalucar one](https://www.nytimes.com/interactive/2018/11/04/technology/jobs-not-mobs.html), tracking the proliferation of a political meme.

I encountered something similar at Tapestry Conference in November -- [where I gave a talk](https://www.youtube.com/watch?v=PpAfmTgcGPY) by the way. Mollie Pettit presented some [great work](https://www.youtube.com/watch?v=v4VunaCburc) she's doing with the ACLU of Illinois, that examines racial bias in traffic incidents. Mollie's presentation was a standout among two days of wonderful talks. And the standout charts from Mollie's talk used beeswarms in the same manner the NYT journalists did (although her analysis doesn't use time on the x-axis). Afterward, I asked her how they were made. She told me something more specific than "D3", but that's all I remembered.

I've never actually made a real data visualization in D3. Still, I've spent some time trying to understand it, and a lot more time understanding Javascript and web development (two things I didn't know the first time tried to play with D3). So with some downtime around the holidays, I decided to work towards building this data vis.  Not knowing what the hell I'm doing in D3, the right place to start was by googling, finding something that looked like it could be modified to become what I needed, pasting it into RStudio, 

I ended up using Nate Vack's block ["Beeswarm plot with gravity and collisions"](http://bl.ocks.org/njvack/1316832), I didn't care about the gravity, but "collisions" was the piece I was most stumped on. Getting that into RStudio's way of working with D3 stumped me for a bit. The trick was to replace the section of the block where `svg` was defined, because the RStudio package `rd2d3` handles that by exposing a predefined `svg` variable for you to reference in your Javascript code.

Nate's code defines `nodes`, and each node is randomly assigned a `y`-value based on the `norm()` function defined at the top. Then the nodes are passed into `D3.layout.force`

Here is what Nate's chart looks like:

```{d3 echo=FALSE, data=c(1,2,3), d3_version=3}
function norm() {
  var res, i;
  res = 0;
  for (i = 0; i < 10; i += 1) {
    res += Math.random()*2-1
  }
  return res;
}

var w = 500,
    h = 500;

var nodes = d3.range(400).map(function() { 
  var true_y = (norm()*50)+250;
  return {
    radius: 4, 
    y: true_y,
    true_x: 250,
    true_y: true_y }
  });

var force = d3.layout.force()
    .gravity(0)
    .charge(0)
    .friction(0.9)
    .nodes(nodes)
    .size([w, h]);

var root = nodes[0];
root.radius = 0;
root.fixed = true;

force.start();

svg.selectAll("circle")
    .data(nodes)
  .enter().append("svg:circle")
    .attr("r", function(d) { return d.radius; })
    .style("fill", 'steelblue')
    .style("stroke", "black");

force.on("tick", function(e) {
  var q,
    node,
    i = 0,
    n = nodes.length;
    
  var q = d3.geom.quadtree(nodes);

  while (++i < n) {
    node = nodes[i];
    q.visit(collide(node));
    xerr = node.x - node.true_x;
    yerr = node.y - node.true_y;
    node.x -= xerr*0.005;
    node.y -= yerr*0.8;
  }
  


  svg.selectAll("circle")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
});

function collide(node) {
  var r = node.radius,
    nx1,
    nx2,
    ny1,
    ny2,
    xerr,
    yerr;
    
  nx1 = node.x - r;
  nx2 = node.x + r;
  ny1 = node.y - r;
  ny2 = node.y + r;
      
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node.radius + quad.point.radius;
      if (l < r) {
        // we're colliding.
        var xnudge, ynudge, nudge_factor;
        nudge_factor = (l - r) / l * .4;
        xnudge = x*nudge_factor;
        ynudge = y*nudge_factor;
        node.x -= xnudge;
        node.y -= ynudge;
        quad.point.x += xnudge;
        quad.point.y += ynudge;
      }
    }
    return x1 > nx2
        || x2 < nx1
        || y1 > ny2
        || y2 < ny1;
  };
}
```

It seemed like the right place to start, but the chart I have in my head is different from that in a few ways:

1. I want the main axis to be horizontal.
1. Circle color should encode a categorical variable.
1. The circle size should encode a continuous variable.

The variable radius piece was the easiest.  The original block had a line that said `var radius = 4,` in the loop that randomly created the circles.  I replaced it with to assign each circle a radius randomly based on a uniform distribution between zero and seven `var radius = 7 * Math.random(),`

```{d3 echo=FALSE, data=c(1,2,3), d3_version=3}
function norm() {
  var res, i;
  res = 0;
  for (i = 0; i < 10; i += 1) {
    res += Math.random()*2-1
  }
  return res;
}

var w = 500,
    h = 500;

var nodes = d3.range(400).map(function() { 
  var true_y = (norm()*50)+250;
  return {
    radius: 7 * Math.random(), 
    y: true_y,
    true_x: 250,
    true_y: true_y }
  });

var force = d3.layout.force()
    .gravity(0)
    .charge(0)
    .friction(0.9)
    .nodes(nodes)
    .size([w, h]);

var root = nodes[0];
root.radius = 0;
root.fixed = true;

force.start();

svg.selectAll("circle")
    .data(nodes)
  .enter().append("svg:circle")
    .attr("r", function(d) { return d.radius; })
    .style("fill", 'steelblue')
    .style("stroke", "black");

force.on("tick", function(e) {
  var q,
    node,
    i = 0,
    n = nodes.length;
    
  var q = d3.geom.quadtree(nodes);

  while (++i < n) {
    node = nodes[i];
    q.visit(collide(node));
    xerr = node.x - node.true_x;
    yerr = node.y - node.true_y;
    node.x -= xerr*0.005;
    node.y -= yerr*0.8;
  }
  


  svg.selectAll("circle")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
});

function collide(node) {
  var r = node.radius,
    nx1,
    nx2,
    ny1,
    ny2,
    xerr,
    yerr;
    
  nx1 = node.x - r;
  nx2 = node.x + r;
  ny1 = node.y - r;
  ny2 = node.y + r;
      
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node.radius + quad.point.radius;
      if (l < r) {
        // we're colliding.
        var xnudge, ynudge, nudge_factor;
        nudge_factor = (l - r) / l * .4;
        xnudge = x*nudge_factor;
        ynudge = y*nudge_factor;
        node.x -= xnudge;
        node.y -= ynudge;
        quad.point.x += xnudge;
        quad.point.y += ynudge;
      }
    }
    return x1 > nx2
        || x2 < nx1
        || y1 > ny2
        || y2 < ny1;
  };
}
```

To encode color, I first added `color` as a property of each node, randomly assigning it one of two hex codes. To pick colors, I literally just typed letters in having no idea what colors would come out, and kind of liked it.  Then in the section that starts with `svg.selectAll`

```{d3 echo=FALSE, data=c(1,2,3), d3_version=3}
function norm() {
  var res, i;
  res = 0;
  for (i = 0; i < 10; i += 1) {
    res += Math.random()*2-1
  }
  return res;
}

var w = 500,
    h = 500;

var nodes = d3.range(400).map(function() { 
  var true_y = (norm()*50)+250;
  return {
    radius: 7 * Math.random(), 
    y: true_y,
    true_x: 250,
    true_y: true_y,
    color: ['#123456', '#4bab56'][Math.floor(Math.random() + .5)] }
  });

var force = d3.layout.force()
    .gravity(0)
    .charge(0)
    .friction(0.9)
    .nodes(nodes)
    .size([w, h]);

var root = nodes[0];
root.radius = 0;
root.fixed = true;

force.start();

svg.selectAll("circle")
    .data(nodes)
  .enter().append("svg:circle")
    .attr("r", function(d) { return d.radius; })
    .style("fill", d => d.color)
    .style("stroke", "black")

force.on("tick", function(e) {
  var q,
    node,
    i = 0,
    n = nodes.length;
    
  var q = d3.geom.quadtree(nodes);

  while (++i < n) {
    node = nodes[i];
    q.visit(collide(node));
    xerr = node.x - node.true_x;
    yerr = node.y - node.true_y;
    node.x -= xerr*0.005;
    node.y -= yerr*0.8;
  }
  


  svg.selectAll("circle")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
});

function collide(node) {
  var r = node.radius,
    nx1,
    nx2,
    ny1,
    ny2,
    xerr,
    yerr;
    
  nx1 = node.x - r;
  nx2 = node.x + r;
  ny1 = node.y - r;
  ny2 = node.y + r;
      
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node.radius + quad.point.radius;
      if (l < r) {
        // we're colliding.
        var xnudge, ynudge, nudge_factor;
        nudge_factor = (l - r) / l * .4;
        xnudge = x*nudge_factor;
        ynudge = y*nudge_factor;
        node.x -= xnudge;
        node.y -= ynudge;
        quad.point.x += xnudge;
        quad.point.y += ynudge;
      }
    }
    return x1 > nx2
        || x2 < nx1
        || y1 > ny2
        || y2 < ny1;
  };
}
```

Then to swap the axis, I needed to switch `x` and `y`. I was only sort of guessing at what the code did, I figured I needed to change `true_x` and `true_y`.  After some poking, I got it.  In addition to swapping coordinates in the nodes, I also needed to swap the coefficients on `xerr` and `yerr` in the while loop. the Here's the full code with all the changes (I also added an axis):

```{d3 echo=FALSE, data=c(1,2,3), d3_version=3}
function norm() {
  var res, i;
  res = 0;
  for (i = 0; i < 10; i += 1) {
    res += Math.random()*2-1
  }
  return res;
}

var w = 500,
    h = 500;

var nodes = d3.range(400).map(function() { 
  var true_y = (norm()*50)+250;
  return {
    radius: 7 * Math.random(), 
    x: true_y,
    true_x: true_y,
    true_y: 200,
    color: ['#123456', '#4bab56'][Math.floor(Math.random() + .5)] }
  });


var force = d3.layout.force()
    .gravity(0)
    .charge(0)
    .friction(0.9)
    .nodes(nodes)
    .size([w, h]);

var root = nodes[0];
root.radius = 0;
root.fixed = true;

force.start();

svg.selectAll("circle")
    .data(nodes)
  .enter().append("svg:circle")
    .attr("r", function(d) { return d.radius; })
    .style("fill", d => d.color)
    .style("stroke", "black")

force.on("tick", function(e) {
  var q,
    node,
    i = 0,
    n = nodes.length;
    
  var q = d3.geom.quadtree(nodes);

  while (++i < n) {
    node = nodes[i];
    q.visit(collide(node));
    xerr = node.x - node.true_x;
    yerr = node.y - node.true_y;
    node.x -= xerr*0.5;
    node.y -= yerr*0.008;
  }
  



  svg.selectAll("circle")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
});

function collide(node) {
  var r = node.radius,
    nx1,
    nx2,
    ny1,
    ny2,
    xerr,
    yerr;
    
  nx1 = node.x - r;
  nx2 = node.x + r;
  ny1 = node.y - r;
  ny2 = node.y + r;
      
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node.radius + quad.point.radius;
      if (l < r) {
        // we're colliding.
        var xnudge, ynudge, nudge_factor;
        nudge_factor = (l - r) / l * .4;
        xnudge = x*nudge_factor;
        ynudge = y*nudge_factor;
        node.x -= xnudge;
        node.y -= ynudge;
        quad.point.x += xnudge;
        quad.point.y += ynudge;
      }
    }
    return x1 > nx2
        || x2 < nx1
        || y1 > ny2
        || y2 < ny1;
  };
}
```

### Next Steps I might not take

I'm excited by the progress, although this is still a little ways from visualizing any data. There are a lot of places to go from here. Here is a jargon-heavy list of good steps to iterate on this tiny bit of code that are mostly indepedent of each other.

1. Move the data simulator into R and use R2D3 to pass that in, possibly in a Shiny app.
1. Find some actual data to visualize, and make sure areas are proportional instead of radii.
1. Just keep poking at params of the existing script, with the aim of understanding `d3.layout.force` and `d3.geom.quadtree` a little better.
1. Find another D3 example for packing circles that looks a little cleaner and start over.
1. Rather than copy and paste from a block, just try to write some fresh D3 code.
1. Package the existing script into an htmlwidget.
1. Find an R package for collision detection.
1. Just give up on another small project before it's a real thing.
1. Think a bit harder about how this visualization distorts the data, especially before I try to use it in my job.


#### Here's the code:

```{d3 results=FALSE, data=c(1,2,3), d3_version=3}
function norm() {
  var res, i;
  res = 0;
  for (i = 0; i < 10; i += 1) {
    res += Math.random()*2-1
  }
  return res;
}

var w = 500,
    h = 500;

var nodes = d3.range(400).map(function() { 
  var true_y = (norm()*50)+250;
  return {
    radius: 7 * Math.random(), 
    x: true_y,
    true_x: true_y,
    true_y: 200,
    color: ['#123456', '#4bab56'][Math.floor(Math.random() + .5)] }
  });

var force = d3.layout.force()
    .gravity(0)
    .charge(0)
    .friction(0.9)
    .nodes(nodes)
    .size([w, h]);

var root = nodes[0];
root.radius = 0;
root.fixed = true;

force.start();

svg.selectAll("circle")
    .data(nodes)
  .enter().append("svg:circle")
    .attr("r", function(d) { return d.radius; })
    .style("fill", d => d.color)
    .style("stroke", "black")

force.on("tick", function(e) {
  var q,
    node,
    i = 0,
    n = nodes.length;
    
  var q = d3.geom.quadtree(nodes);

  while (++i < n) {
    node = nodes[i];
    q.visit(collide(node));
    xerr = node.x - node.true_x;
    yerr = node.y - node.true_y;
    node.x -= xerr*0.5;
    node.y -= yerr*0.008;
  }

  svg.selectAll("circle")
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
});

function collide(node) {
  var r = node.radius,
    nx1,
    nx2,
    ny1,
    ny2,
    xerr,
    yerr;
    
  nx1 = node.x - r;
  nx2 = node.x + r;
  ny1 = node.y - r;
  ny2 = node.y + r;
      
  return function(quad, x1, y1, x2, y2) {
    if (quad.point && (quad.point !== node)) {
      var x = node.x - quad.point.x,
          y = node.y - quad.point.y,
          l = Math.sqrt(x * x + y * y),
          r = node.radius + quad.point.radius;
      if (l < r) {
        // we're colliding.
        var xnudge, ynudge, nudge_factor;
        nudge_factor = (l - r) / l * .4;
        xnudge = x*nudge_factor;
        ynudge = y*nudge_factor;
        node.x -= xnudge;
        node.y -= ynudge;
        quad.point.x += xnudge;
        quad.point.y += ynudge;
      }
    }
    return x1 > nx2
        || x2 < nx1
        || y1 > ny2
        || y2 < ny1;
  };
}
```


